// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/spacesprotocol/explorer-backend/pkg/types"
)

const deleteMempool = `-- name: DeleteMempool :exec
DELETE FROM transactions
WHERE block_hash IS NULL
`

func (q *Queries) DeleteMempool(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteMempool)
	return err
}

const getMempoolTransactions = `-- name: GetMempoolTransactions :many
SELECT txid, tx_hash, version, size, vsize, weight, locktime, fee, block_hash, index
FROM transactions
WHERE block_hash IS NULL
ORDER BY index
LIMIT $1 OFFSET $2
`

type GetMempoolTransactionsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetMempoolTransactions(ctx context.Context, arg GetMempoolTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getMempoolTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.Txid,
			&i.TxHash,
			&i.Version,
			&i.Size,
			&i.Vsize,
			&i.Weight,
			&i.Locktime,
			&i.Fee,
			&i.BlockHash,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByTxid = `-- name: GetTransactionByTxid :one
SELECT
  transactions.txid, transactions.tx_hash, transactions.version, transactions.size, transactions.vsize, transactions.weight, transactions.locktime, transactions.fee, transactions.block_hash, transactions.index,
  COALESCE(blocks.height, -1)::integer AS block_height_not_null
FROM transactions
  LEFT JOIN blocks ON (transactions.block_hash = blocks.hash)
WHERE transactions.txid = $1
`

type GetTransactionByTxidRow struct {
	Txid               types.Bytes
	TxHash             *types.Bytes
	Version            int32
	Size               int64
	Vsize              int64
	Weight             int64
	Locktime           int32
	Fee                int64
	BlockHash          *types.Bytes
	Index              sql.NullInt32
	BlockHeightNotNull int32
}

func (q *Queries) GetTransactionByTxid(ctx context.Context, txid types.Bytes) (GetTransactionByTxidRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByTxid, txid)
	var i GetTransactionByTxidRow
	err := row.Scan(
		&i.Txid,
		&i.TxHash,
		&i.Version,
		&i.Size,
		&i.Vsize,
		&i.Weight,
		&i.Locktime,
		&i.Fee,
		&i.BlockHash,
		&i.Index,
		&i.BlockHeightNotNull,
	)
	return i, err
}

const getTransactionsByBlockHeight = `-- name: GetTransactionsByBlockHeight :many
SELECT
  transactions.txid, transactions.tx_hash, transactions.version, transactions.size, transactions.vsize, transactions.weight, transactions.locktime, transactions.fee, transactions.block_hash, transactions.index,
  COALESCE(blocks.height, -1)::integer AS block_height_not_null
FROM
  transactions
  INNER JOIN blocks ON (transactions.block_hash = blocks.hash)
WHERE blocks.height = $1
ORDER BY transactions.index
LIMIT $2 OFFSET $3
`

type GetTransactionsByBlockHeightParams struct {
	Height int32
	Limit  int32
	Offset int32
}

type GetTransactionsByBlockHeightRow struct {
	Txid               types.Bytes
	TxHash             *types.Bytes
	Version            int32
	Size               int64
	Vsize              int64
	Weight             int64
	Locktime           int32
	Fee                int64
	BlockHash          *types.Bytes
	Index              sql.NullInt32
	BlockHeightNotNull int32
}

func (q *Queries) GetTransactionsByBlockHeight(ctx context.Context, arg GetTransactionsByBlockHeightParams) ([]GetTransactionsByBlockHeightRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByBlockHeight, arg.Height, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByBlockHeightRow{}
	for rows.Next() {
		var i GetTransactionsByBlockHeightRow
		if err := rows.Scan(
			&i.Txid,
			&i.TxHash,
			&i.Version,
			&i.Size,
			&i.Vsize,
			&i.Weight,
			&i.Locktime,
			&i.Fee,
			&i.BlockHash,
			&i.Index,
			&i.BlockHeightNotNull,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTransaction = `-- name: InsertTransaction :exec
INSERT INTO transactions (txid, tx_hash, version, size, vsize, weight, locktime, fee, block_hash, index)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertTransactionParams struct {
	Txid      types.Bytes
	TxHash    *types.Bytes
	Version   int32
	Size      int64
	Vsize     int64
	Weight    int64
	Locktime  int32
	Fee       int64
	BlockHash *types.Bytes
	Index     sql.NullInt32
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, insertTransaction,
		arg.Txid,
		arg.TxHash,
		arg.Version,
		arg.Size,
		arg.Vsize,
		arg.Weight,
		arg.Locktime,
		arg.Fee,
		arg.BlockHash,
		arg.Index,
	)
	return err
}
