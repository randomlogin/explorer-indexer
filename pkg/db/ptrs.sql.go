// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ptrs.sql

package db

import (
	"context"

	"github.com/spacesprotocol/explorer-indexer/pkg/types"
)

const commitmentExists = `-- name: CommitmentExists :one
SELECT EXISTS(SELECT 1 FROM commitments WHERE name = $1 AND state_root = $2)
`

type CommitmentExistsParams struct {
	Name      string
	StateRoot *types.Bytes
}

func (q *Queries) CommitmentExists(ctx context.Context, arg CommitmentExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, commitmentExists, arg.Name, arg.StateRoot)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getCommitmentByBlockHashAndName = `-- name: GetCommitmentByBlockHashAndName :one
SELECT block_hash, txid, name, state_root, history_hash, revocation FROM commitments WHERE block_hash = $1 AND name = $2
`

type GetCommitmentByBlockHashAndNameParams struct {
	BlockHash types.Bytes
	Name      string
}

func (q *Queries) GetCommitmentByBlockHashAndName(ctx context.Context, arg GetCommitmentByBlockHashAndNameParams) (Commitment, error) {
	row := q.db.QueryRow(ctx, getCommitmentByBlockHashAndName, arg.BlockHash, arg.Name)
	var i Commitment
	err := row.Scan(
		&i.BlockHash,
		&i.Txid,
		&i.Name,
		&i.StateRoot,
		&i.HistoryHash,
		&i.Revocation,
	)
	return i, err
}

const getCommitmentsByBlockHeightAndName = `-- name: GetCommitmentsByBlockHeightAndName :many
SELECT commitments.block_hash, commitments.txid, commitments.name, commitments.state_root, commitments.history_hash, commitments.revocation FROM commitments
JOIN blocks ON commitments.block_hash = blocks.hash
WHERE blocks.height = $1 AND commitments.name = $2
`

type GetCommitmentsByBlockHeightAndNameParams struct {
	Height int32
	Name   string
}

func (q *Queries) GetCommitmentsByBlockHeightAndName(ctx context.Context, arg GetCommitmentsByBlockHeightAndNameParams) ([]Commitment, error) {
	rows, err := q.db.Query(ctx, getCommitmentsByBlockHeightAndName, arg.Height, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Commitment{}
	for rows.Next() {
		var i Commitment
		if err := rows.Scan(
			&i.BlockHash,
			&i.Txid,
			&i.Name,
			&i.StateRoot,
			&i.HistoryHash,
			&i.Revocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCommitmentByName = `-- name: GetLatestCommitmentByName :one
SELECT commitments.block_hash, commitments.txid, commitments.name, commitments.state_root, commitments.history_hash, commitments.revocation FROM commitments
JOIN blocks ON commitments.block_hash = blocks.hash
WHERE commitments.name = $1
ORDER BY blocks.height DESC
LIMIT 1
`

func (q *Queries) GetLatestCommitmentByName(ctx context.Context, name string) (Commitment, error) {
	row := q.db.QueryRow(ctx, getLatestCommitmentByName, name)
	var i Commitment
	err := row.Scan(
		&i.BlockHash,
		&i.Txid,
		&i.Name,
		&i.StateRoot,
		&i.HistoryHash,
		&i.Revocation,
	)
	return i, err
}

const insertCommitment = `-- name: InsertCommitment :exec
INSERT INTO commitments (block_hash, txid, name, state_root, history_hash, revocation) VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertCommitmentParams struct {
	BlockHash   types.Bytes
	Txid        types.Bytes
	Name        string
	StateRoot   *types.Bytes
	HistoryHash *types.Bytes
	Revocation  bool
}

func (q *Queries) InsertCommitment(ctx context.Context, arg InsertCommitmentParams) error {
	_, err := q.db.Exec(ctx, insertCommitment,
		arg.BlockHash,
		arg.Txid,
		arg.Name,
		arg.StateRoot,
		arg.HistoryHash,
		arg.Revocation,
	)
	return err
}
